#!/usr/bin/env python
import argparse
import json


def main():
    '''
    Derive up(down)stream calorimeter energy correction.

    This script expects json file with fit results from "cec_process_events" script.
    '''
    parser = argparse.ArgumentParser(description='Yay, derive up(down)stream correction parameters!')

    parser.add_argument('-f', '--functions', type=str, default=[], action='append',
                        help='fit functions (in ROOT notation)')

    required_arguments = parser.add_argument_group('required arguments')
    required_arguments.add_argument('-i', '--input-file', type=str, required=True, help='Input file path')
    required_arguments.add_argument('-t', '--type', '--corr-type', type=str, required=True,
                                    choices=['upstream', 'downstream'], help='select correction type')

    args = parser.parse_args()

    from ROOT import gROOT
    gROOT.SetBatch(True)

    try:
        with open(args.input_file) as results_file:
            data = json.load(results_file)
            if data.get('results'):
                results = data['results']
            else:
                print('ERROR: Input file does not contain "results" array!')
                print('       ' + args.input_file)
                exit(1)
    except IOError:
        print('ERROR: Input file not found!')
        print('       ' + args.input_file)
        exit(1)

    graphs = {}
    for result in results:
        if result['type'] != args.corr_type:
            continue
        if not graphs.get(result['name']):
            graph = {}
            graph['x'] = []
            graph['y'] = []
            graph['z'] = []
            graph['z_err'] = []
            graph['x_label'] = 'E_{cluster} [GeV]'
            graph['y_label'] = '#theta [deg]'
            graph['z_label'] = result['name']
            graph['index'] = result['index']
            graphs[result['name']] = graph
        graphs[result['name']]['x'].append(result['momentum'])
        graphs[result['name']]['y'].append(result['theta'])
        graphs[result['name']]['z'].append(result['value'])
        graphs[result['name']]['z_err'].append(result['error'])

    from ROOT import TGraphErrors, TGraph2DErrors, TF2

    graphs = sorted(graphs.items(), key=lambda graph: graph[1]['index'])

    param_counter = 97
    for graph_name, graph_dict in graphs:
        graph = TGraphErrors()
        graph.SetName('graph_' + args.corr_type + '_' + corr_depenece + '_' +
                      graph_name.replace('#', '').replace('{', '').replace('}', ''))
        for i in range(len(graph_dict['x'])):
            graph.SetPoint(i, graph_dict['x'][i], graph_dict['y'][i])
            graph.SetPointError(i, 0., graph_dict['y_err'][i])

        graph.GetXaxis().SetTitle(graph_dict['x_label'])
        graph.GetYaxis().SetTitle(graph_dict['y_label'])

        if (graph.GetN() < 3):
            print('WARNING: Number of points in parameter graph is too small!')
            exit(0)

        try:
            overhang = 0.1 * abs(max(graph_dict['x']) - min(graph_dict['x']))
            func = TF1("func", args.functions[graph_dict['index']],
                       min(graph_dict['x']) - overhang,
                       max(graph_dict['x']) + overhang)
        except IndexError:
            print('WARNING: Fitting function for parameter "' + graph_name + '" not provided.')
            print('         Skipping fit!')
        else:
            for i in range(func.GetNpar()):
                func.SetParName(i, chr(param_counter))
                param_counter += 1

            result = graph.Fit(func, "SR")

            corr_params = []
            try:
                with open('corr_params.json') as infile:
                    data = json.load(infile)
                    if data.get('corr_params'):
                        corr_params = data['corr_params']
            except IOError:
                pass

            for i in range(func.GetNpar()):
                param_dict = {}
                param_dict['name'] = func.GetParName(i)
                param_dict['value'] = result.Get().Parameter(i)
                param_dict['error'] = result.Get().Error(i)
                param_dict['func'] = args.functions[graph_dict['index']]
                param_dict['mother_param'] = graph_name
                param_dict['type'] = args.corr_type
                param_dict['dependence'] = corr_depenece
                param_dict['index'] = i

                corr_params = [p for p in corr_params if not (p['name'] == param_dict['name'] and
                                                              p['type'] == param_dict['type'] and
                                                              p['dependence'] == param_dict['dependence'])]
                corr_params.append(param_dict)

            with open('corr_params.json', 'w') as outfile:
                json.dump({'corr_params': corr_params}, outfile, indent=4)

        plot(graph, graph.GetName())

    dict_chi2 = {}
    dict_chi2['x'] = []
    dict_chi2['y'] = []
    for result in results:
        if result['type'] != args.corr_type:
            continue
        if args.energy and result['theta'] != args.const_theta:
            continue
        if args.theta and result['momentum'] != args.const_energy:
            continue
        if result['index'] != 0:
            continue
        dict_chi2['x'].append(result[corr_depenece])
        dict_chi2['y'].append(result['chi2']/result['ndf'])

    if not dict_chi2['x']:
        return

    graph_chi2 = TGraph()
    graph_chi2.SetName('graph_' + args.corr_type + '_' + corr_depenece + '_chi2')
    for i in range(len(dict_chi2['x'])):
        graph_chi2.SetPoint(i, dict_chi2['x'][i], dict_chi2['y'][i])

    if args.energy:
        graph_chi2.GetXaxis().SetTitle('E_{cluster} [GeV]')
    if args.theta:
        graph_chi2.GetXaxis().SetTitle('#theta [deg]')
    graph_chi2.GetYaxis().SetTitle('#chi^{2} / NDF')
    plot(graph_chi2, graph_chi2.GetName())


def plot(obj, plotname, plot_notes=[]):
    from ROOT import gPad, gStyle
    from ROOT import TCanvas, TPaveText
    from ROOT import kBlue
    canvas = TCanvas('canvas_' + plotname, 'Canvas', 350, 350)
    gPad.SetLeftMargin(.13)
    gPad.SetTopMargin(.05)
    gPad.SetRightMargin(.05)

    gStyle.SetOptStat(11)
    gStyle.SetOptFit(1111)

    obj.SetLineColor(kBlue)
    obj.SetLineWidth(2)
    obj.SetMarkerColor(kBlue)
    obj.SetMarkerStyle(20)
    obj.SetMarkerSize(.5)

    if obj.ClassName() == 'TGraphErrors':
        obj.SetMaximum(1.4 * max(obj.GetY()))

    note = TPaveText(.2, .7, .5, .9, 'brNDC')
    note.SetFillStyle(0)
    note.SetFillColor(0)
    note.SetBorderSize(0)
    note.SetTextColor(1)
    note.SetTextFont(42)
    note.SetTextAlign(11)
    for note_text in plot_notes:
        note.AddText(note_text)

    obj.Draw('APEL')
    note.Draw()
    canvas.Print(plotname + '.pdf')


if __name__ == '__main__':
    main()
