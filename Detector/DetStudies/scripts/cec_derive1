#!/usr/bin/env python
import argparse
import json


def main():
    '''
    Derive up(down)stream calorimeter energy correction dependent on cluster energy or theta.

    This script expects json file with fit results from "cec_process_events" script.
    '''
    parser = argparse.ArgumentParser(description='Yay, derive up(down)stream correction parameters!')

    parser.add_argument('-f', '--functions', type=str, default=[], action='append',
                        help='fit functions (in ROOT notation)')
    parser.add_argument('-n', '--note', action='append', default=[], type=str,
                        help='additional note to be displayed in the plots')
    parser.add_argument('--energy-slice', type=float, default=50.,
                        help='select energy slice for the correction derivation')
    parser.add_argument('--theta-slice', type=float, default=90.,
                        help='select theta slice for the correction derivation')

    required_arguments = parser.add_argument_group('required arguments')
    required_arguments.add_argument('-i', '--input-file', type=str, required=True, help='Input file path')
    required_arguments.add_argument('-d', '--corr-dependence', type=str, required=True,
                                    choices=['energy', 'theta'],
                                    help='select variable on which the correction is dependent')
    required_arguments.add_argument('-t', '--corr-type', type=str, required=True,
                                    choices=['upstream', 'downstream'], help='select correction type')

    args = parser.parse_args()

    print('*********************************************************')
    print('*  Calorimeter Energy Correction: Derive 1D correction  *')
    print('*********************************************************')

    if not args.note:
        args.note.append('FCC-ee, LAr Calo')
        args.note.append('electron')
        if args.corr_dependence == 'energy':
            args.note.append('#theta slice: %i deg' % (args.theta_slice))
        if args.corr_dependence == 'theta':
            args.note.append('E_{cluster} slice: %i GeV' % (args.energy_slice))
        print('WARNING: Using default plot legend notes.')

    from ROOT import gROOT
    gROOT.SetBatch(True)

    print('INFO: Loading input file from:')
    print('      ' + args.input_file)

    try:
        with open(args.input_file) as results_file:
            data = json.load(results_file)
            if data.get('results'):
                results = data['results']
            else:
                print('ERROR: Input file does not contain "results" array!')
                print('       ' + args.input_file)
                exit(1)
    except IOError:
        print('ERROR: Input file not found!')
        print('       ' + args.input_file)
        exit(1)

    graphs = {}
    for result in results:
        if result['type'] != args.corr_type:
            continue
        if args.corr_dependence == 'energy' and args.theta_slice != result['theta']:
            continue
        if args.corr_dependence == 'theta' and args.energy_slice != result['energy']:
            continue
        if not graphs.get(result['name']):
            graph = {}
            graph['x'] = []
            graph['y'] = []
            graph['y_err'] = []
            if args.corr_dependence == 'energy':
                graph['x_label'] = 'E_{cluster} [GeV]'
            if args.corr_dependence == 'theta':
                graph['x_label'] = '#theta [deg]'
            graph['y_label'] = result['name']
            graph['index'] = result['index']
            graphs[result['name']] = graph
        graphs[result['name']]['x'].append(result[args.corr_dependence])
        graphs[result['name']]['y'].append(result['value'])
        graphs[result['name']]['y_err'].append(result['error'])

    from ROOT import TGraphErrors, TGraph, TF1

    graphs = sorted(graphs.items(), key=lambda graph: graph[1]['index'])

    param_counter = 97
    for graph_name, graph_dict in graphs:
        graph_dict['x'], graph_dict['y'], graph_dict['y_err'] = zip(*sorted(zip(graph_dict['x'],
                                                                                graph_dict['y'],
                                                                                graph_dict['y_err'])))

        graph = TGraphErrors()
        graph.SetName('graph_' + args.corr_type + '_' + args.corr_dependence + '_' +
                      graph_name.replace('#', '').replace('{', '').replace('}', ''))
        for x, y, y_err in zip(graph_dict['x'], graph_dict['y'], graph_dict['y_err']):
            graph.SetPoint(graph.GetN(), x, y)
            graph.SetPointError(graph.GetN() - 1, 0., y_err)

        graph.GetXaxis().SetTitle(graph_dict['x_label'])
        graph.GetYaxis().SetTitle(graph_dict['y_label'])

        if (graph.GetN() < 3):
            print('WARNING: Number of points in parameter graph is too small!')
            exit(0)

        try:
            overhang = 0.1 * abs(max(graph_dict['x']) - min(graph_dict['x']))
            func = TF1("func", args.functions[graph_dict['index']],
                       min(graph_dict['x']) - overhang,
                       max(graph_dict['x']) + overhang)
        except IndexError:
            print('WARNING: Fitting function for parameter "' + graph_name + '" not provided.')
            print('         Skipping fit!')
        else:
            for i in range(func.GetNpar()):
                func.SetParName(i, chr(param_counter))
                param_counter += 1

            result = graph.Fit(func, "SR")

            corr_params = []
            try:
                with open('corr_params.json') as infile:
                    data = json.load(infile)
                    if data.get('corr_params'):
                        corr_params = data['corr_params']
            except IOError:
                pass

            for i in range(func.GetNpar()):
                param_dict = {}
                param_dict['name'] = func.GetParName(i)
                param_dict['value'] = result.Get().Parameter(i)
                param_dict['error'] = result.Get().Error(i)
                param_dict['func'] = args.functions[graph_dict['index']]
                param_dict['mother_param'] = graph_name
                param_dict['type'] = args.corr_type
                param_dict['dependence'] = args.corr_dependence
                param_dict['index'] = i
                if args.corr_dependence == 'energy':
                    param_dict['theta_slice'] = args.theta_slice
                if args.corr_dependence == 'theta':
                    param_dict['energy_slice'] = args.energy_slice

                corr_params = [p for p in corr_params if not (p['name'] == param_dict['name'] and
                                                              p['type'] == param_dict['type'] and
                                                              p['dependence'] == param_dict['dependence'])]
                corr_params.append(param_dict)

            with open('corr_params.json', 'w') as outfile:
                json.dump({'corr_params': corr_params}, outfile, indent=4)

        plot(graph, graph.GetName(), args.note)

    dict_chi2 = {}
    dict_chi2['x'] = []
    dict_chi2['y'] = []
    for result in results:
        if result['type'] != args.corr_type:
            continue
        if args.corr_dependence == 'energy' and args.theta_slice != result['theta']:
            continue
        if args.corr_dependence == 'theta' and args.energy_slice != result['energy']:
            continue
        if result['index'] != 0:
            continue
        dict_chi2['x'].append(result[args.corr_dependence])
        dict_chi2['y'].append(result['chi2']/result['ndf'])

    if not dict_chi2['x']:
        return

    dict_chi2['x'], dict_chi2['y'] = zip(*sorted(zip(dict_chi2['x'], dict_chi2['y'])))

    graph_chi2 = TGraph()
    graph_chi2.SetName('graph_' + args.corr_type + '_' + args.corr_dependence + '_chi2')
    for x, y in zip(dict_chi2['x'], dict_chi2['y']):
        graph_chi2.SetPoint(graph_chi2.GetN(), x, y)

    if args.corr_dependence == 'energy':
        graph_chi2.GetXaxis().SetTitle('E_{cluster} [GeV]')
    if args.corr_dependence == 'theta':
        graph_chi2.GetXaxis().SetTitle('#theta [deg]')
    graph_chi2.GetYaxis().SetTitle('#chi^{2} / NDF')
    plot(graph_chi2, graph_chi2.GetName(), args.note)


def plot(obj, plotname, plot_notes=[]):
    from ROOT import gPad, gStyle
    from ROOT import TCanvas, TPaveText
    from ROOT import kBlue
    canvas = TCanvas('canvas_' + plotname, 'Canvas', 350, 350)
    gPad.SetLeftMargin(.13)
    gPad.SetTopMargin(.05)
    gPad.SetRightMargin(.05)

    gStyle.SetOptStat(11)
    gStyle.SetOptFit(1111)

    obj.SetLineColor(kBlue)
    obj.SetLineWidth(2)
    obj.SetMarkerColor(kBlue)
    obj.SetMarkerStyle(20)
    obj.SetMarkerSize(.5)
    obj.GetXaxis().SetTitleOffset(1.3)
    obj.GetYaxis().SetTitleOffset(1.9)

    obj.SetMaximum(1.4 * max(obj.GetY()))

    note = TPaveText(.2, .7, .5, .9, 'brNDC')
    note.SetFillStyle(0)
    note.SetFillColor(0)
    note.SetBorderSize(0)
    note.SetTextColor(1)
    note.SetTextFont(42)
    note.SetTextAlign(11)
    for note_text in plot_notes:
        note.AddText(note_text)

    obj.Draw('APEL')
    note.Draw()
    canvas.Print(plotname + '.pdf')


if __name__ == '__main__':
    main()
