#!/usr/bin/env python
import os
import argparse
import math
import json


def main():
    '''
    Histogram and fit up(down)stream energy vs. first (last) calorimeter layer for FCC-ee LAr calorimeter.

    This script expects root file containing TTree "events" with three branches:
     * std::vector<double> energyInLayer -- energy deposited in calorimeter layers
                                         -- layer_id 0 at position 0
                                         -- etc.
     * std::vector<double> energyInCryo -- energy deposited in the whole cryostat and also in its parts
                                        -- energy deposited in whole cryostat at position 0
                                        -- energy deposited in front cryostat at position 1
                                        -- energy deposited in back cryostat at position 2
                                        -- energy deposited in cryostat sides at position 3
                                        -- energy deposited in front LAr bath at position 4
                                        -- energy deposited in back LAr bath at position 5
     * std::vector<double> particleVec  -- momentum of initial particle
                                        -- px at position 0
                                        -- py at position 1
                                        -- pz at position 2

    Output of this script is input for the calo_energy_corr script
    '''
    parser = argparse.ArgumentParser(description='Yay, histogram and fit up(down)stream energy vs. energy in layer!')

    parser.add_argument('-u', '--upstream', action='store_true', default=False, help='upstream material')
    parser.add_argument('-d', '--downstream', action='store_true', default=False, help='downstream material')
    parser.add_argument('-l', '--layer-id', type=int, default=0, help='ID of the calorimeter layer')
    parser.add_argument('-f', '--function', type=str, help='fit functions (in ROOT notation)')
    parser.add_argument('-r', '--rebin-factor', type=int, help='Number of bins to be merged')
    parser.add_argument('-n', '--note', action='append', default=[], type=str,
                        help='note to be displayed in the plots')

    required_arguments = parser.add_argument_group('required arguments')
    required_arguments.add_argument('-i', '--input-file', type=str, required=True, help='Input file path')

    args = parser.parse_args()

    if args.upstream == args.downstream:
        print('ERROR: Select "upstream" or "downstream"!')
        exit(1)

    if not args.layer_id:
        if args.upstream:
            args.layer_id = 0
        else:
            args.layer_id = -1
        print('WARNING: Using default calorimeter layer id %i.' % args.layer_id)

    if not args.function:
        args.function = 'pol1'
        print('WARNING: Using default fitting function "pol1".')

    if args.upstream:
        material_str = 'upstream'
    if args.downstream:
        material_str = 'downstream'

    if not os.path.isfile(args.input_file):
        print('WARNING: Input ROOT file not found!')
        print('         ' + args.input_file)
        exit(1)

    from ROOT import gROOT, TFile, TH2D, TF1
    gROOT.SetBatch(True)

    infile = TFile(args.input_file, 'READ')

    if not infile.events:
        print('ERROR: TTree "events" not found in the provided ROOT file!')
        infile.Close()
        exit(1)

    n_events = infile.events.GetEntries()
    n_bins = math.ceil(math.sqrt(n_events))

    hist_name = '%sEnergy__energyInLayer_%i' % (material_str, args.layer_id)
    hist_title = ';Energy in layer id: %i [GeV];%s Energy [GeV]' % (args.layer_id, material_str.capitalize())
    hist = TH2D(hist_name, hist_title, int(n_bins), 0., 0., int(n_bins), 0., 0.)
    hist.Sumw2()
    hist.SetDirectory(0)

    particle_momentum = 0.
    particle_theta = 0.
    for event in infile.events:
        particle_momentum += get_momentum(event)
        particle_theta += get_theta(event)

        if args.upstream:
            cryo_energy = event.energyInCryo[1] + event.energyInCryo[4]
        if args.downstream:
            cryo_energy = event.energyInCryo[2] + event.energyInCryo[5]
        hist.Fill(cryo_energy, event.energyInLayer[args.layer_id])
    infile.Close()
    hist.BufferEmpty()

    particle_momentum /= n_events
    particle_theta /= n_events
    print('Initial particle momentum: %.2f GeV' % (particle_momentum))
    print('                 theta:    %.2f deg' % (particle_theta))

    if args.rebin_factor:
        hist.Rebin(args.rebin_factor)

    plot_name = '%s_vs_layer_%i_%ideg_%iGeV' % (material_str, args.layer_id,
                                                round(particle_theta), round(particle_momentum))
    plot_notes = []
    plot_notes.append('FCC-ee, LAr Calo')
    plot_notes.append('e^{-}, %i GeV, %i deg' % (round(particle_momentum), round(particle_theta)))
    plot(hist, 'hist_' + plot_name, plot_notes)

    profile = hist.ProfileX('profile_x')
    profile.GetYaxis().SetTitle('Mean ' + hist.GetYaxis().GetTitle())

    if count_bins_with_error(profile) < 3:
        print('WARNING: Number of non empty bins too small, ignoring histogram!')
        exit(0)

    func_from = hist.GetXaxis().GetBinLowEdge(hist.GetXaxis().GetFirst())
    func_to = hist.GetXaxis().GetBinUpEdge(hist.GetXaxis().GetLast())
    func = TF1('func', args.function, func_from, func_to)

    result = profile.Fit(func, 'SR')

    plot(profile, 'profile_' + plot_name, plot_notes)

    results = []
    try:
        with open('results_%s.json' % material_str) as results_file:
            data = json.load(results_file)
            if data.get('results'):
                results = data['results']
    except IOError:
        pass

    for i in range(func.GetNpar()):
        param_dict = {}
        param_dict['name'] = func.GetParName(i)
        param_dict['momentum'] = int(round(particle_momentum))
        param_dict['theta'] = int(round(particle_theta))
        param_dict['value'] = result.Get().Parameter(i)
        param_dict['error'] = result.Get().Error(i)
        param_dict['chi2'] = result.Get().Chi2()
        param_dict['ndf'] = result.Get().Ndf()
        if param_dict not in results:
            results.append(param_dict)

    with open('results_%s.json' % material_str, 'w') as results_file:
        json.dump({'results': results}, results_file, indent=4)


def get_momentum(event):
    momentum = math.sqrt(math.pow(event.particleVec[0], 2) +
                         math.pow(event.particleVec[1], 2) +
                         math.pow(event.particleVec[2], 2))

    return momentum


def get_theta(event):
    theta = math.atan(event.particleVec[1] / event.particleVec[2])
    if theta < 0:
        theta = math.pi + theta
    theta = 180 * theta / math.pi

    return theta


def plot(obj, plotname, plot_notes=[]):
    from ROOT import gPad, gStyle
    from ROOT import TCanvas, TPaveText
    canvas = TCanvas('canvas_' + plotname, 'Canvas', 450, 450)
    gPad.SetLeftMargin(.13)
    gPad.SetTopMargin(.05)

    gStyle.SetOptStat(11)
    gStyle.SetOptFit(1111)

    print(obj.ClassName())

    if 'TH2' in obj.ClassName():
        gPad.SetRightMargin(.13)
        draw_options = 'COLZ'

    if 'TProfile' in obj.ClassName():
        gPad.SetRightMargin(.05)
        draw_options = ''

    note = TPaveText(.2, .7, .5, .9, 'brNDC')
    note.SetFillStyle(0)
    note.SetFillColor(0)
    note.SetBorderSize(0)
    note.SetTextColor(1)
    note.SetTextFont(42)
    note.SetTextAlign(11)
    for note_text in plot_notes:
        note.AddText(note_text)

    obj.Draw(draw_options)
    note.Draw()
    canvas.Print(plotname + '.pdf')


def count_bins_with_error(hist):
    num = 0
    for i in range(hist.GetYaxis().GetFirst(), hist.GetXaxis().GetLast() + 1):
        err = hist.GetBinError(i)
        if err == 0.:
            continue
        num += 1

    return num


if __name__ == '__main__':
    main()
